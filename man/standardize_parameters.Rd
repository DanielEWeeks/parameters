% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/standardize_parameters.R
\name{standardize_parameters}
\alias{standardize_parameters}
\title{Get Standardized Model Parameters}
\usage{
standardize_parameters(model, robust = FALSE, method = "refit",
  verbose = TRUE, ...)
}
\arguments{
\item{model}{A statistical model.}

\item{robust}{Logical, if \code{TRUE}, centering is done by substracting the
median from the variables and divide it by the median absolute deviation
(MAD). If \code{FALSE}, variables are standardized by substracting the
mean and divide it by the standard deviation (SD).
the}

\item{method}{The method used for standardizing the parameters. Can be \code{"refit"} (default).}

\item{verbose}{Toggle warnings on or off.}

\item{...}{Arguments passed to or from other methods.}
}
\description{
Compute standardized model parameters (coefs).
}
\details{
\strong{Methods:}
\itemize{
 \item \strong{refit}: This method is based on a complete model re-fit after standardizing the data. Hence, this method is equal to standardizing the variables before fitting the model. It is the most accurate, especially for parameters related to interactions, but it is also the most computationally costly.
 \item \strong{2sd}: Same as \code{method = "refit"}, however, standardization is done by dividing by two times the SD or MAD (depending on \code{robust}).
 \item \strong{full}: Post-hoc standardization of the model parmaters, based on multiplying the coefficients by the standard deviation of the related terms and dividing by the standard deviation of the outcome.
 \item \strong{classic}: Similar to \code{method = "full"}, but factors are treated differently. See below.
}
\strong{Standardization of factors}
\cr \cr
The most accurate method of getting standardized coefficients is to standardize
the data before fitting the model. This is similar to \code{method = "refit"}.
\code{method = "full"} performs a post-hoc standardization by multiplying
the coefficients with the standard deviation of the related model term, then
dividing by the standard deviation of the model's response. However, this
method is only applied to numeric variables and thus the results probably
differ from standardized coefficients from other functions like
\code{sjstats::std_beta()} or \code{lm.beta::lm.beta()}. The reason for this
behaviour is that in particular for more complex models (including interaction
or polynomial or spline terms) \code{method = "full"} returned standardized
coefficients that were closer to the more accurate approach of standardizing
the data before fitting the model, as compared to the "classic" method implemented
in \code{sjstats::std_beta()} or \code{lm.beta::lm.beta()}. However,
\code{method = "classic"} mimics this "classic" behaviour.
}
\examples{
data(iris)

model <- lm(Sepal.Length ~ Species * Petal.Width, data = iris)
standardize_parameters(model, method = "refit")
standardize_parameters(model, method = "refit", robust = TRUE)
standardize_parameters(model, method = "2sd")
standardize_parameters(model, method = "2sd", robust = TRUE)
standardize_parameters(model, method = "full")
standardize_parameters(model, method = "full", robust = TRUE)

iris$binary <- ifelse(iris$Sepal.Width > 3, 1, 0)
model <- glm(binary ~ Species * Sepal.Length, data = iris, family = "binomial")
standardize_parameters(model, method = "refit")
standardize_parameters(model, method = "refit", robust = TRUE)
standardize_parameters(model, method = "full")
standardize_parameters(model, method = "full", robust = TRUE)

}
